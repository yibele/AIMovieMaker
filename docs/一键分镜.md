# 技术集成指南：Gemini 多视角网格生成系统 (Grid-Gen Protocol)

## 1. 核心设计哲学

**“以一当十”**。
不要为每一张变体图单独发送 API 请求。利用 Gemini 3 Pro 强大的指令遵循能力和 4K 分辨率，强制模型在一张画布上绘制分镜网格（Grid），然后在客户端进行“物理切割”。

*   **优势**：极大降低 API 延迟（一次等待），显著节省 Token 成本，保证角色/风格的高度一致性（因为是在同一个 Context 下生成的）。

## 2. 关键技术栈

*   **模型 (Model)**: `gemini-3-pro-image-preview` (必须支持高指令遵循和文字渲染能力)。
*   **SDK**: `@google/genai` (或者标准的 REST API)。
*   **配置**: 强制 `4K` 分辨率 (为了保证切割后的小图清晰度)。

## 3. 核心步骤拆解

### 步骤一：Prompt 构建 (Prompt Engineering)

这是最关键的一步。你不能只是把用户的 Prompt 发过去，你需要把它包裹在一个**“结构化强制指令”**里。

**Prompt 模板结构示例（TypeScript）：**

```typescript
// 可以配置的参数：网格的行数和列数
const gridRows = 2; // 或 3
const gridCols = 2; // 或 3
const totalViews = gridRows * gridCols; // 总共的视角数量

// 用户输入的原始 Prompt
const user_input_prompt = "一个赛博朋克武士在未来城市屋顶";

const finalPrompt = `
MANDATORY LAYOUT: Create a precise ${gridRows}x${gridCols} GRID containing exactly ${totalViews} distinct panels.
- The output image MUST be a single image divided into a ${gridRows} (rows) by ${gridCols} (columns) matrix.
- There must be EXACTLY ${gridRows} horizontal rows and ${gridCols} vertical columns.
- Each panel must be completely separated by a thin, distinct, solid black line.
- DO NOT create a collage. DO NOT overlap images. DO NOT create random sizes. 
- The grid structure must be perfectly aligned for slicing.

Subject Content: "${user_input_prompt}"

Styling Instructions:
- Each panel shows the SAME subject/scene from a DIFFERENT angle (e.g., Front, Side, Back, Action, Close-up).
- Maintain perfect consistency of the character/object across all panels.
- Cinematic lighting, high fidelity, 8k resolution.

Negative Constraints:
- No text, no captions, no UI elements.
- No watermarks.
- No broken grid lines.
`;

console.log(finalPrompt);
/* 
输出示例 (当 gridRows=2, gridCols=2 时):
MANDATORY LAYOUT: Create a precise 2x2 GRID containing exactly 4 distinct panels.
- The output image MUST be a single image divided into a 2 (rows) by 2 (columns) matrix.
- There must be EXACTLY 2 horizontal rows and 2 vertical columns.
- Each panel must be completely separated by a thin, distinct, solid black line.
- DO NOT create a collage. DO NOT overlap images. DO NOT create random sizes. 
- The grid structure must be perfectly aligned for slicing.

Subject Content: "一个赛博朋克武士在未来城市屋顶"

Styling Instructions:
- Each panel shows the SAME subject/scene from a DIFFERENT angle (e.g., Front, Side, Back, Action, Close-up).
- Maintain perfect consistency of the character/object across all panels.
- Cinematic lighting, high fidelity, 8k resolution.

Negative Constraints:
- No text, no captions, no UI elements.
- No watermarks.
- No broken grid lines.
*/
```

**重点解析：**

*   **`MANDATORY LAYOUT`**：用大写强调布局是强制性的，促使模型严格遵守。
*   **Grid 定义**：明确指定行数 (`gridRows`) 和列数 (`gridCols`)，防止模型自由发挥画成拼贴画或不规则布局。
*   **Separation**：要求通过“细、清晰、实心黑线”分割，虽然程序是按像素切，但让模型画线能增加对齐的概率。
*   **Subject Consistency**：强调是“同一个主体”的“不同角度”，这是角色设计图或多视角展示的核心需求。

### 步骤二：API 请求配置

在发送给 Google GenAI 接口时，必须包含以下关键配置：

```javascript
import { GoogleGenAI } from "@google/genai";
// 假设你已经有了 API Key
const apiKey = process.env.GOOGLE_API_KEY; 
const genAI = new GoogleGenAI({ apiKey });

const requestConfig = {
  model: 'gemini-3-pro-image-preview', // 指定使用的模型
  config: {
    imageConfig: {
      aspectRatio: '16:9', // 图片的宽高比，根据你的需求选择 '1:1', '4:3', '16:9'
      imageSize: '4K'      // 核心！必须强制 4K，否则切出来的图可能因为分辨率不足而模糊
    }
  },
  contents: {
    parts: [
      // 如果用户上传了参考图，你需要将它们转换为 Base64 格式并作为 inlineData 传入
      // 参考图的格式为 { mimeType: string, data: string (base64) }
      // 例如：
      // {
      //   inlineData: {
      //     mimeType: "image/jpeg",
      //     data: "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" 
      //   }
      // },
      // 最后，将上面构造好的 `finalPrompt` 作为文本部分传入
      { text: finalPrompt } 
    ]
  }
};

// 示例调用 (实际应用中需要封装在 async 函数中)
// try {
//   const result = await genAI.models.generateContent(requestConfig);
//   const response = result.response;
//   // 处理返回的 Base64 图像数据
//   let fullImageBase64 = '';
//   for (const part of response.candidates?.[0]?.content?.parts || []) {
//     if (part.inlineData) {
//       fullImageBase64 = `data:image/png;base64,${part.inlineData.data}`;
//       break;
//     }
//   }
//   if (!fullImageBase64) throw new Error("未能生成 Grid 图片");
//   // 接着调用 sliceImageGrid
//   const slicedImages = await sliceImageGrid(fullImageBase64, gridRows, gridCols);
//   console.log("切割后的图片数组:", slicedImages);
// } catch (error) {
//   console.error("生成内容失败:", error);
// }
```

### 步骤三：图像切割算法 (Client-Side Slicing)

拿到 API 返回的那张巨大的 Base64 图片后，需要在客户端（通常是前端）把它切开。这里推荐使用 HTML5 Canvas 实现。

**通用逻辑代码 (TypeScript/Web):**

```typescript
/**
 * 将一张大图切割成 gridRows * gridCols 张小图
 * @param base64Data API 返回的完整大图 (data:image/png;base64,...)
 * @param rows 网格的行数 (例如 2)
 * @param cols 网格的列数 (例如 2)
 * @returns Promise<string[]> 包含每一块小图的 Base64 数据数组
 */
const sliceImageGrid = (base64Data: string, rows: number, cols: number): Promise<string[]> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous"; // 必须设置，以避免 Canvas 跨域污染问题
    
    img.onload = () => {
      const totalWidth = img.width;
      const totalHeight = img.height;
      
      // 计算每一块的尺寸 (向下取整，避免浮点数导致边缘溢出)
      const pieceWidth = Math.floor(totalWidth / cols);
      const pieceHeight = Math.floor(totalHeight / rows);
      
      const pieces: string[] = []; // 用于存储切割后小图的 Base64 数据的数组
      
      // 创建一个临时的 Canvas 元素用于绘制和导出每一块小图
      const canvas = document.createElement('canvas');
      canvas.width = pieceWidth;
      canvas.height = pieceHeight;
      const ctx = canvas.getContext('2d'); // 获取 2D 渲染上下文
      
      if (!ctx) {
        return reject(new Error("无法获取 Canvas 上下文，请检查浏览器兼容性。"));
      }

      // 双重循环遍历网格，切割每一块小图
      for (let r = 0; r < rows; r++) { // 遍历行
        for (let c = 0; c < cols; c++) { // 遍历列
            // 在每次绘制前清空 Canvas
            ctx.clearRect(0, 0, pieceWidth, pieceHeight);
            
            // 核心切割逻辑：drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
            // image: 要绘制的图片对象
            // sx, sy: 源图像中矩形选择框的左上角 x, y 坐标
            // sWidth, sHeight: 源图像中矩形选择框的宽度和高度
            // dx, dy: 目标 Canvas 中放置图像的左上角 x, y 坐标
            // dWidth, dHeight: 目标 Canvas 中放置图像的宽度和高度
            ctx.drawImage(
                img, 
                c * pieceWidth,   // 源图像中当前列的起始 X 坐标
                r * pieceHeight,  // 源图像中当前行的起始 Y 坐标
                pieceWidth,       // 截取的宽度
                pieceHeight,      // 截取的高度
                0, 0,             // 在临时 Canvas 上从 (0,0) 开始绘制
                pieceWidth, pieceHeight // 绘制到临时 Canvas 的完整宽度和高度
            );
            
            // 将当前绘制的 Canvas 内容导出为 PNG 格式的 Base64 字符串
            pieces.push(canvas.toDataURL('image/png'));
        }
      }
      resolve(pieces); // 返回包含所有小图 Base64 数据的数组
    };
    
    // 图片加载失败时处理错误
    img.onerror = (e) => reject(new Error(`图片加载失败: ${e.type}`));
    // 设置图片的源为传入的 Base64 数据，触发图片加载
    img.src = base64Data;
  });
};
```

## 4. 完整流程总结 (End-to-End Workflow)

1.  **用户交互**：用户在你的程序中输入 Prompt (如 "一个赛博朋克武士")，并选择生成网格的大小（如 2x2）。
2.  **Prompt 封装**：你的程序根据用户输入，结合预设的强制性布局指令，生成一个包含网格结构的 `finalPrompt`。如果有参考图，也一并转换为 Base64 格式。
3.  **API 请求**：使用 `@google/genai` SDK (或直接调用 REST API)，以 `gemini-3-pro-image-preview` 模型、`4K` 强制分辨率，发送 `finalPrompt` 和所有参考图。
4.  **接收响应**：从 API 返回中获取一张巨大的 Base64 格式的网格图片。
5.  **客户端切割**：调用 `sliceImageGrid` 函数，将接收到的 Base64 大图，按照预设的行数和列数（例如 2x2）切割成多张独立的 Base64 小图。
6.  **结果展示**：你的程序将这些切割后的小图展示给用户，用户会感觉一次性生成了多张不同视角的图片。
