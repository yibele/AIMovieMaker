app.jsx
import React, { useCallback, useMemo } from 'react';
import {
  ReactFlow,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  addEdge,
  getNodesBounds,
} from '@xyflow/react';

import '@xyflow/react/dist/style.css';
import ImageStackNode from './ImageStackNode';

const initialNodes = [
  { id: '1', type: 'stack', position: { x: 0, y: 0 }, data: { images: [{ src: 'https://via.placeholder.com/150' }], expanded: false } },
  { id: '2', type: 'stack', position: { x: 0, y: 170 }, data: { images: [{ src: 'https://via.placeholder.com/150/0000FF/808080' }], expanded: false } },
];
const initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];

export default function App() {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  // We need to pass functions to the nodes. To avoid circular deps or stale closures, 
  // we can use a stable ref or just rely on setNodes functional updates.
  // Ideally, these are defined outside, but they need access to setNodes.

  const onExpand = useCallback((id) => {
    setNodes((nds) =>
      nds.map((n) => {
        if (n.id === id) {
          return { ...n, data: { ...n.data, expanded: true } };
        }
        // Collapse others? Optional. Let's collapse others for cleaner UI.
        if (n.type === 'stack' && n.data.expanded) {
          return { ...n, data: { ...n.data, expanded: false } };
        }
        return n;
      })
    );
  }, [setNodes]);

  const onSelectMain = useCallback((id, newMainImage) => {
    setNodes((nds) =>
      nds.map((n) => {
        if (n.id === id) {
          return { ...n, data: { ...n.data, mainImage: newMainImage, expanded: false } };
        }
        return n;
      })
    );
  }, [setNodes]);


  const nodeTypes = useMemo(() => ({
    stack: ImageStackNode
  }), []);

  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges],
  );

  const onFileUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const id = `node_${Date.now()}`;
      const newNode = {
        id,
        type: 'stack',
        position: { x: Math.random() * 400, y: Math.random() * 400 },
        data: {
          images: [{ src: e.target.result }],
          expanded: false,
          onExpand, // These will be attached during render? No, data is static JSON usually, but ReactFlow supports functions.
          // Ideally we'd use a custom hook or context inside the node, but this works for simple apps.
          // Wait, I need to make sure these are passed to initial nodes too or attached dynamically. 
          // actually, better to attach them in a useEffect or just pass them here.
          onSelectMain
        },
      };
      setNodes((nds) => nds.concat(newNode));
    };
    reader.readAsDataURL(file);
  };

  // Helper to ensure initial nodes also get the callbacks
  // A cleaner pattern is to put callbacks in the node component via a Context, but sticking to data for now.
  // We need to inject callbacks into initialNodes effectively or use a transform.
  // Let's just update the initialNodes definition above to include them? No, functions can't be in top-level cons.
  // We will patch them in a useEffect for simplicity of this Refactor step.
  React.useEffect(() => {
    setNodes((nds) => nds.map(n => ({
      ...n,
      data: { ...n.data, onExpand, onSelectMain }
    })));
  }, [onExpand, onSelectMain, setNodes]);

  const onGroupNodes = () => {
    const selectedNodes = nodes.filter((node) => node.selected && node.type === 'stack');
    if (selectedNodes.length < 2) {
      alert('Please select at least 2 stacks/images to group.');
      return;
    }

    const bounds = getNodesBounds(selectedNodes);

    // Merge all images from selected stacks
    const images = selectedNodes.flatMap(n => n.data.images || []);
    const stackId = `stack_${Date.now()}`;

    const stackNode = {
      id: stackId,
      type: 'stack',
      position: { x: bounds.x, y: bounds.y },
      data: {
        images,
        mainImage: images[0],
        expanded: false,
        onExpand,
        onSelectMain
      },
    };

    const remainingNodes = nodes.filter(n => !selectedNodes.find(sn => sn.id === n.id));
    setNodes([...remainingNodes, stackNode]);
  };

  const onPaneClick = useCallback(() => {
    setNodes((nds) =>
      nds.map((n) => {
        if (n.type === 'stack' && n.data.expanded) {
          return { ...n, data: { ...n.data, expanded: false } };
        }
        return n;
      })
    );
  }, [setNodes]);

  const showGroupButton = nodes.filter(n => n.selected && n.type === 'stack').length >= 2;

  return (
    <div style={{ width: '100vw', height: '100vh', position: 'relative' }}>
      <div style={{ position: 'absolute', top: 10, left: 10, zIndex: 10, display: 'flex', gap: '10px' }}>
        <div style={{ padding: 10, background: '#333', borderRadius: 5 }}>
          <input type="file" accept="image/*" onChange={onFileUpload} style={{ color: 'white' }} />
        </div>
        {showGroupButton && (
          <button
            onClick={onGroupNodes}
            style={{
              padding: '10px 20px',
              background: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer',
              fontWeight: 'bold',
            }}
          >
            Group Selected
          </button>
        )}
      </div>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onPaneClick={onPaneClick}
        nodeTypes={nodeTypes}
        fitView
      >
        <Controls />
        <Background variant="dots" gap={12} size={1} />
      </ReactFlow>
    </div>
  );
}

imagenodestack.jxs
/**
 * ImageStackNode Component Overview
 * --------------------------------
 * This component implements a "Unified Node" architecture where every image node is treated as a "Stack".
 * - Single Image = Stack with 1 item.
 * - Grouped Images = Stack with N items.
 *
 * Core Logic & Features:
 * 1. **Data Structure**:
 *    - `data.images`: Array of { src, id } objects.
 *    - `data.mainImage`: The image currently displayed as the cover.
 *    - `data.expanded`: Boolean state controlling the grid view.
 *    - `data.onExpand`: Callback to toggle expansion (passed from parent).
 *    - `data.onSelectMain`: Callback to change the cover image (passed from parent).
 *
 * 2. **Visual States**:
 *    - **Collapsed (Default)**:
 *      - Displays only the `currentMain` image.
 *      - All other images are hidden behind it (via z-index).
 *      - Shows a "Badge" with the count if count > 1.
 *    - **Expanded (Grid View)**:
 *      - Activated by clicking the **Badge**.
 *      - Images animate out to formed a generic grid (2 columns wide).
 *      - Calculation: `x = (index % 2) * 160`, `y = Math.floor(index / 2) * 160`.
 *
 * 3. **Interaction Logic (Crucial)**:
 *    - **Click Image**:
 *      - If Collapsed: Selects the node (standard React Flow behavior). Shows Toolbar. DOES NOT EXPAND.
 *      - If Expanded: Triggers `onSelectMain`, sets the clicked image as cover, and collapses the stack.
 *    - **Click Badge**:
 *      - Toggles the `expanded` state. This is the ONLY way to open the stack.
 *
 * 4. **Toolbar**:
 *    - Uses `<NodeToolbar>` to show actions (Upscale, remove BG, etc.).
 *    - Visible when `selected` OR `expanded`.
 */

import React, { memo } from 'react';
import { Handle, Position, NodeToolbar } from '@xyflow/react';

export default memo(({ data, id, selected }) => {
    const { images = [], mainImage, expanded } = data;
    const count = images.length;
    // Fallback: If no mainImage specified, use the first one in the array.
    const currentMain = mainImage || images[0] || {};

    // HANDLER: Toggle Expansion
    // Triggered ONLY by the red badge.
    const handleToggle = (e) => {
        e.stopPropagation(); // Prevent node selection interference
        data.onExpand(id);
    };

    // HANDLER: Image Interaction
    // Differentiates behavior based on current state (Collapsed vs Expanded).
    const handleImageClick = (img, e) => {
        if (expanded) {
            e.stopPropagation();
            // In Grid View: Clicking an image selects it as the new cover.
            data.onSelectMain(id, img);
        }
        // In Collapsed View: We do NOTHING here.
        // We let the event propagate so React Flow selects the node and shows the toolbar.
    };

    return (
        <div style={{ position: 'relative', width: 150, height: 150 }}>
            {/* 
              Node Toolbar 
              - Floating UI above the node.
              - Visible when node is Selected or Expanded.
            */}
            <NodeToolbar isVisible={selected || expanded} position={Position.Top}>
                <div style={{ display: 'flex', gap: '8px', padding: '8px', background: '#333', borderRadius: '8px', boxShadow: '0 4px 6px rgba(0,0,0,0.3)' }}>
                    <button style={{ background: '#555', border: 'none', borderRadius: '4px', padding: '4px 8px', color: 'white', fontSize: '12px', cursor: 'pointer' }}>高清放大</button>
                    <button style={{ background: '#555', border: 'none', borderRadius: '4px', padding: '4px 8px', color: 'white', fontSize: '12px', cursor: 'pointer' }}>抠图</button>
                    <button style={{ background: '#555', border: 'none', borderRadius: '4px', padding: '4px 8px', color: 'white', fontSize: '12px', cursor: 'pointer' }}>下载</button>
                    <button style={{ background: '#ff4d4f', border: 'none', borderRadius: '4px', padding: '4px 8px', color: 'white', fontSize: '12px', cursor: 'pointer' }}>删除</button>
                </div>
            </NodeToolbar>

            {/* Connection Handle (Input) */}
            <Handle type="target" position={Position.Top} style={{ zIndex: -1 }} />

            {/* 
              Image Rendering Loop 
              - Renders ALL images in the stack.
              - Controls position via CSS Transform (`translate`).
            */}
            {images.map((img, index) => {
                // GRID CALCULATION
                // Determines target position when expanded.
                const col = index % 2;
                const row = Math.floor(index / 2);
                const x = expanded ? col * 160 : 0; // 160 = 150px width + 10px gap
                const y = expanded ? row * 160 : 0;

                const isMain = img.src === currentMain.src;

                // Z-Index: Main image must be on top when collapsed.
                const zIndex = !expanded && isMain ? 10 : 1;

                return (
                    <div
                        key={index}
                        onClick={(e) => handleImageClick(img, e)}
                        style={{
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            width: 150,
                            height: 150,
                            borderRadius: 8,
                            border: '2px solid #555',
                            // Highlight the main image with a pink border ONLY when expanded
                            borderColor: expanded && isMain ? '#ff0072' : '#555',
                            background: '#222',
                            overflow: 'hidden',

                            // ANIMATION
                            // Smoothly transition transform (position) and box-shadow.
                            transform: `translate(${x}px, ${y}px)`,
                            transition: 'transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), box-shadow 0.2s',

                            zIndex: zIndex,
                            boxShadow: expanded ? '0 10px 20px rgba(0,0,0,0.2)' : '0 4px 6px rgba(0,0,0,0.1)',
                            cursor: 'pointer',
                        }}
                    >
                        <img
                            src={img.src}
                            alt={`stack-${index}`}
                            style={{ width: '100%', height: '100%', objectFit: 'cover' }}
                        />
                    </div>
                );
            })}

            {/* 
              Count Badge 
              - The trigger for expansion.
              - Visible only if there is more than 1 image.
            */}
            {count > 1 && (
                <div
                    onClick={handleToggle}
                    style={{
                        position: 'absolute',
                        top: -10,
                        right: -10,
                        background: '#ff0072',
                        color: 'white',
                        borderRadius: '50%',
                        width: 24,
                        height: 24,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        fontSize: 12,
                        fontWeight: 'bold',
                        cursor: 'pointer',
                        boxShadow: '0 2px 4px rgba(0,0,0,0.5)',
                        zIndex: 100, // Always on top
                        transition: 'transform 0.2s',
                        transform: expanded ? 'scale(0.8)' : 'scale(1)', // Subtle click effect
                    }}
                >
                    {count}
                </div>
            )}

            {/* Connection Handle (Output) */}
            <Handle type="source" position={Position.Bottom} style={{ zIndex: -1 }} />
        </div>
    );
});
